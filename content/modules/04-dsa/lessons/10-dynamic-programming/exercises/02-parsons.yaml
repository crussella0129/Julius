type: parsons
id: "10-dynamic-programming-parsons-01"
prompt: "Arrange these lines to implement a memoized recursive Fibonacci function."
blocks:
  - "def fib(n, memo=None):"
  - "    if memo is None:"
  - "        memo = {}"
  - "    if n in memo:"
  - "        return memo[n]"
  - "    if n <= 1:"
  - "        return n"
  - "    memo[n] = fib(n - 1, memo) + fib(n - 2, memo)"
  - "    return memo[n]"
solution_order: [0, 1, 2, 3, 4, 5, 6, 7, 8]
distractors:
  - "    memo[n] = fib(n - 1) + fib(n - 2)"
  - "    if n == 0:"
hints:
  - "Check the memo first to avoid recomputation."
  - "Pass the memo dictionary to recursive calls so all levels share it."
concept_tags:
  - memoization
  - overlapping-subproblems
